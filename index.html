<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="Generate random PNG, JPEG, GIF, SVG or text files with exact size and dimensions">
  <meta name="keywords" content="image generator, text file generator, PNG size generator, random file generator">
  <meta name="author" content="dionisiy13@gmail.com">
  <meta http-equiv="Cache-Control" content="max-age=300, must-revalidate">
  <meta http-equiv="Pragma" content="cache">
  <meta http-equiv="Expires" content="300">
  <title>Random File Generator (Exact Size)</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <script type="text/javascript">
    (function(c,l,a,r,i,t,y){
        c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
        t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
        y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
    })(window, document, "clarity", "script", "ucvn1c2e9w");
</script>
</head>
<body class="bg-light">
<div class="container mt-5">
  <div class="card shadow-lg">
    <div class="card-body">
      <h3 class="card-title text-center mb-4">File Generator (Exact Size)</h3>
      <div class="mb-3">
        <label class="form-label">File Type:</label>
        <select id="fileType" class="form-select" onchange="toggleDimensions()">
          <option value="png">PNG</option>
          <option value="jpeg">JPEG</option>
          <option value="gif">GIF</option>
          <option value="svg">SVG</option>
          <option value="txt">TXT</option>
        </select>
      </div>
      <div class="mb-3" id="widthGroup">
        <label class="form-label">Width (px):</label>
        <input type="number" class="form-control" id="w" value="300">
      </div>
      <div class="mb-3" id="heightGroup">
        <label class="form-label">Height (px):</label>
        <input type="number" class="form-control" id="h" value="300">
      </div>
      <div class="mb-3">
        <label class="form-label">Target File Size (KB):</label>
        <input type="number" class="form-control" id="kb" value="300" max="2097152">
      </div>
      <div class="d-grid mb-3">
        <button onclick="generateFile()" class="btn btn-primary">Generate File</button>
      </div>
      <div class="progress" style="height: 20px;">
        <div id="progressBar" class="progress-bar" role="progressbar" style="width: 0%">0%</div>
      </div>
      <p class="text-center mt-3" id="fileSizePreview"></p>
         <div class="text-center" style="font-size: 9pt;"><p>Made by <a href="https://www.linkedin.com/in/denys-kurasov/" target="_blank">Denys Kurasov</a> hands</p></div>
    </div>

  </div>
</div>




<script>
function toggleDimensions() {
  const fileType = document.getElementById("fileType").value;
  const isText = fileType === "txt";
  document.getElementById("widthGroup").style.display = isText ? "none" : "block";
  document.getElementById("heightGroup").style.display = isText ? "none" : "block";
}

toggleDimensions();

async function generateFile() {
  const fileType = document.getElementById("fileType").value;
  const width = parseInt(document.getElementById("w").value);
  const height = parseInt(document.getElementById("h").value);
  const sizeKBInput = parseInt(document.getElementById("kb").value);
  const sizeBytes = sizeKBInput * 1024;
  const progressBar = document.getElementById("progressBar");
  const fileSizePreview = document.getElementById("fileSizePreview");

  if (sizeKBInput > 2097152) {
    alert("Maximum allowed size is 2 GB (2097152 KB)");
    return;
  }

  progressBar.style.width = '0%';
  progressBar.textContent = '0%';
  fileSizePreview.textContent = '';

  let data; // Uint8Array or encoded text
  const encoder = new TextEncoder();

  if (["png", "jpeg", "gif"].includes(fileType)) {
    // Generate with requested dimensions
    const canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext("2d");
    const imgData = ctx.createImageData(width, height);
    for (let i = 0; i < imgData.data.length; i += 4) {
      imgData.data[i] = Math.random() * 255;
      imgData.data[i + 1] = Math.random() * 255;
      imgData.data[i + 2] = Math.random() * 255;
      imgData.data[i + 3] = 255;
    }
    ctx.putImageData(imgData, 0, 0);

    let imgBlob = await new Promise(r => canvas.toBlob(r, `image/${fileType}`));
    let raw = new Uint8Array(await imgBlob.arrayBuffer());

    if (raw.length < sizeBytes) {
      const out = new Uint8Array(sizeBytes);
      out.set(raw);
      // pad with zeros after the binary (most decoders ignore trailing bytes)
      data = out; // zeros by default
    } else if (raw.length > sizeBytes) {
      // do not redeclare; slice down (may corrupt but meets byte target)
      data = raw.slice(0, sizeBytes);
    } else {
      data = raw;
    }

  } else if (fileType === "svg") {
    const color = `rgb(${rand255()},${rand255()},${rand255()})`;
    const xmlDecl = `<?xml version='1.0' encoding='UTF-8'?>`;
    const svgOpen = `<svg xmlns='http://www.w3.org/2000/svg' width='${width}' height='${height}'>`;
    const svgContent = `<rect width='100%' height='100%' fill='${color}'/>`;
    const svgClose = `</svg>`;

    const unit = '<!--x-->'; // 9 chars
    const base = xmlDecl + svgOpen + svgContent;
    const minSize = (base + svgClose).length;
    if (sizeBytes < minSize) {
      alert(`SVG min size is ${minSize} bytes for current dims; increase target size.`);
      return;
    }
    let remaining = sizeBytes - (base.length + svgClose.length);
    let count = Math.floor(remaining / unit.length);
    let rem = remaining - count * unit.length; // 0..8
    // Build filler with exact bytes: repeat units + one variable-length comment
    let filler = unit.repeat(count);
    if (rem > 0) {
      // Ensure rem >= 7 by borrowing a unit if needed
      if (rem < 7) {
        if (count > 0) {
          count -= 1;
          rem += unit.length; // now 7..16
          filler = unit.repeat(count);
        } else {
          // fall back: put spaces text node inside svg (valid) to reach rem
          filler += ' '.repeat(rem);
          rem = 0;
        }
      }
      if (rem >= 7) {
        const insideLen = rem - 7; // content length inside comment
        filler += `<!----${'x'.repeat(insideLen)}>`; // '<!--' + '-->' with extra x's
      }
    }
    const svgString = base + filler + svgClose;
    data = encoder.encode(svgString);

  } else if (fileType === "txt") {
    let s = '';
    while (s.length < sizeBytes) s += Math.random().toString(36).slice(2);
    data = encoder.encode(s.slice(0, sizeBytes));
  }

  const mime = fileType === 'txt' ? 'text/plain' : (fileType === 'svg' ? 'image/svg+xml' : `image/${fileType}`);
  const blob = new Blob([data], { type: mime });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = `generated.${fileType}`;
  a.click();
  URL.revokeObjectURL(url);

  progressBar.style.width = '100%';
  progressBar.textContent = '100%';
  fileSizePreview.textContent = `Generated file size: ${(blob.size / 1024).toFixed(2)} KB`;
}

function rand255() { return Math.floor(Math.random() * 256); }
</script>
</body>
</html>
